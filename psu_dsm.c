/* This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#define _GNU_SOURCE
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/shm.h>
//#define __USE_GNU
#include <ucontext.h>
#include <unistd.h>
//#include <sys/ucontext.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <unistd.h>
#include <arpa/inet.h>
#include "psu_dsm_msg.h"
#include "psu_dsm_msg_svc.h"
#include "util.h"
#include "psu_dsm.h"

dsm_t *cdsm;

void segv_handler (int signum, siginfo_t *info, void *ucontext)
{
	printf("Recieved signal: %d(SIGSEGV)\n", signum);
	printf("ucontext = %p\n", ucontext);
	printf("fault addr = %p\n", info->si_addr);

	dsm_entry_t entry;
	get_name_from_addr(&entry, info->si_addr, cdsm);

	char local_host[IP_LEN];
	get_local_ipaddr(local_host);


	CLIENT *clnt;
	host_t  *nameserv;

	clnt = clnt_create (local_host, PSU_DSM, PSU_DSM_VERS, "tcp");
		if (clnt == NULL) {
			clnt_pcreateerror (local_host);
			exit (1);
	}

	nameserv = psu_dsm_page_locate_1(&entry.page, clnt);
	if (nameserv == (host_t *) NULL) {	
		clnt_perror (clnt, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

	
	
	CLIENT *clnt2;
	page_t *npage;

	clnt2 = clnt_create (nameserv->ip, PSU_DSM, PSU_DSM_VERS, "tcp");
		if (clnt == NULL) {
			clnt_pcreateerror (nameserv->ip);
			exit (1);
	}

	request_t req;
	req.pageid = entry.page;

	if( ((ucontext_t *)ucontext)->uc_mcontext.gregs[REG_ERR] & 0x2){
		// write fault
		req.mode = RW;
	}
	else{
		// read fault
		req.mode = RO;
	}


	npage = psu_dsm_page_request_1(&req, clnt);
	if (npage == (page_t *) NULL) {	
		clnt_perror (clnt2, "call failed");
	}

#ifndef	DEBUG
	clnt_destroy (clnt2);
#endif	 /* DEBUG */

	mprotect(entry.addr, PAGE_SIZE, PROT_WRITE);

	memcpy(entry.addr, npage->addr, PAGE_SIZE);

	if( ((ucontext_t *)ucontext)->uc_mcontext.gregs[REG_ERR] & 0x2){
		// write fault
		mprotect (entry.addr, PAGE_SIZE, PROT_READ | PROT_WRITE); 
	}
	else{
		// read fault
		mprotect (entry.addr, PAGE_SIZE, PROT_READ); 
	}

	
}

/* Install segv_handler as the handler for SIGSEGV. */
void psu_dsm_init(){
	cdsm = NULL;
	int fd;
	struct sigaction sa;
 	memset (&sa, 0, sizeof (sa));
 	sa.sa_sigaction = &segv_handler;
	sa.sa_flags = SA_SIGINFO;
 	sigaction (SIGSEGV, &sa, NULL);
}


psu_dsm_ptr_t
psu_dsm_malloc(char *name, int size){

	pageid_t page;
	strncpy(page.name, name, NAME_LEN);
	page.size = size;

	CLIENT *clnt;
	int  *result_1;
	char host[IP_LEN];
	get_local_ipaddr(host);

	clnt = clnt_create (host, PSU_DSM, PSU_DSM_VERS, "tcp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
	result_1 = psu_dsm_page_creat_1(&page, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
		exit(1);
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

	if(*result_1 != 1){
		perror("creat failed");
		exit(1);
	}

	
	key_t key;
	int shmid;

	key = hash(name);
	shmid = shmget(key, PAGE_SIZE, 0666);

	if(shmid == -1){
		perror("shmget\n");
		exit(1);
	}

	void *addr = shmat(shmid, (void *)0, 0);


	char fake_ip[IP_LEN];
	insert_dsm(page, fake_ip, cdsm);

	return addr;

	
}

void psu_dsm_free(char* name){

}
